# Интерфейс для работы с школьным API. (21 School)

Простенекий (назовем это так) "нтерфейс" для работы с школьным API, все что нужно это в аргументы конструктора передать ник\логин и пароль, после этого объект сам получит токен, и вы сможете приступить к работе, к сожалению пока что нету таймера, который по истечению валидности токена, обновил бы его.

Так же есть констурктор в который вы можете передать заведомо известный вам токен, если вы переживаете за безопасность данных (ну вдруг вы боитесь что я их украду). Ну и так же это просто удобно для отладки что бы каждый раз не получать новый токен.
```
s21Api api("YOUR_TOKEN");
```

Можете использовать данный код в своих проектах, переделывать и привносить новый функционал и фичи на свое усмотрение.

Если у вас есть какие либо вопросы и предложения стучитесь в телегу @robot3human0.

Так же проект открыт для контрибьюта.

### Зависимости
* curl
* ssl
* json-cpp

Для установки на ubuntu можно воспользоваться такой командой:<br>
```sudo apt install libcurl4-openssl-dev libssl-dev libjsoncpp-dev```

Пример компиляции программы:<br>
```g++ -g main.cc ./s21api.cc -o kebaba -lcurl -lssl -lcrypto -ljsoncpp```

### Простой пример:
```
int main() {
  s21Api api("yourlogin@student.21-school.ru", "YOUR PASS");

  std::cout << api.Campus->campuses() << std::endl;
  std::cout << api.Coalition->participant(50, 666, 30) << std::endl;
  return 0;
}
```

### Замечания:

*Для вызова API "Participant" требуется логин. Так вот на платформу он должен передаваться целиком т.е.: <br> <b>yourlogin@student.21-school.ru</b> но для удобства я сделал что можно вписать и просто логин. Оба следующих примера не будут ошибкой:<br>
<b>
api.Participant->courses("aboba", 120);<br>
api.Participant->courses("aboba@student.21-school.ru", 120);
</b><br>
Другая ситуация если вам нужен специфичный логин, например тестовый которые есть на платформе и у него отсутствует доменное имя ящика, то в конце списка аргументов нужно педеать "0" или "false":
<br><b>
api.Participant->participants("deadpooc", false); <i>(к стати реальный тестовый ник)</i>
</b>
* Так же глобально доступны такие enum "структры"<br>
```
enum Type { 
  ACTIVITY = 1,
  EXAM, 
  TEST 
};
```
```
enum Status {
  ASSIGNED = 1,
  REGISTERED,
  IN_PROGRESS,
  IN_REVIEWS,
  ACCEPTED,
  FAILED
};
```
что так же облегчит вам жизнь. Примеры: <br>
```
api.Participant->projects("werewolf", 30, 10, Status::ACCEPTED);
```
```
api.Event->events("2024-06-30T00:00:00Z", "2024-09-28T00:00:00Z" Type::ACTIVITY, 1, 1);
```

### Планы или нужно сделать:
* Предпологаю нужен таймер для обновления токена. Пока что токен можно только получить автоматом но не обновить.
* Пока особо не задавался вопросом но предпологаю, что может быть было бы полезно, что бы все это работало асинхронно в несколько потоков.